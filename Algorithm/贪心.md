# 贪心算法
## 目录
### 1.Dijkstra算法

#### Dijkstra算法
```
//图的边，增加两个设置函数
class edge implements Comparable<edge>{
    private int v;
    private double w;
    edge(int v,double w){this.v=v;this.w=w;}
    void setWeight(double w){this.w=w;}
    int vertex(){return v;}
    double weight(){return w;}
    @Override
    public int compareTo(edge x){
        return this.v-x.v;
    }
}
class graph{
    private int numv;
    private List<List<edge>>vertex;
    private void init(int n){
        numv=n;
        vertex=new ArrayList<>();
        for (int i = 0; i < n; i++) {
            vertex.add(new ArrayList<edge>());
        }
    }
    graph(int n){init(n);}
    int n(){return numv;}
    int first(int v){
        if(vertex.get(v).size()==0)return numv;
        return vertex.get(v).get(0).vertex();
    }
    int next(int i,int j){
        int temp=Collections.binarySearch(vertex.get(i),new edge(j,0));
        if(temp>=0&&temp+1<vertex.get(i).size())return vertex.get(i).get(temp+1).vertex();
        return numv;
    }
    void setEdge(int i,int j,int w){
        int temp=Collections.binarySearch(vertex.get(i),new edge(j,0));
        if(temp>=0)vertex.get(i).set(temp,new edge(j,w));
        else{
            temp=-temp-1;
            vertex.get(i).add(temp,new edge(j,w));
        }
    }
    double weight(int i,int j){
        int temp=Collections.binarySearch(vertex.get(i),new edge(j,0));
        if(temp>=0)return vertex.get(i).get(temp).weight();
        else return 0;
    }
}
public class Dijkstra {
    static class heap{
        private int maxsize,n;
        private edge[]h;
        //pos数组用来记录顶点v再堆数组h中的位置
        private int[]pos;
        //交换函数，要更新pos数组中的值
        private void swap(int i,int j){
            edge temp=h[i];
            h[i]=h[j];
            h[j]=temp;
            pos[h[i].vertex()]=i;
            pos[h[j].vertex()]=j;
        }
        //判断节点是否是叶子
        boolean isLeaf(int p){return (p>=n/2)&&p<n;}
        private void siftdown(int p){
            while(!isLeaf(p)){
                int l=2*p+1;
                int r=2*p+2;
                if(r<n&&h[r].weight()<h[l].weight())l=r;
                if(h[p].weight()<h[l].weight())return;
                swap(p,l);
                p=l;
            }
        }
        private void buildheap(){
            for (int i = h.length/2-1; i >= 0; i--)siftdown(i);
        }
        heap(edge[]hh,int n,int maxsize){
            h=hh;
            this.n=n;
            this.maxsize=maxsize;
            pos=new int[maxsize];
            for (int i = 0; i < h.length; i++) {
                pos[h[i].vertex()]=i;
            }
            buildheap();
        }
        void siftup(int i){
            while(i!=0&&h[i].weight()<h[(i-1)/2].weight()){
                swap(i,(i-1)/2);
                i=(i-1)/2;
            }
        }
        int remove(){
            swap(0,--n);
            if(n!=0)siftdown(0);
            return h[n].vertex();
        }
        //获取顶点v在堆数组中的位置
        int getPos(int v){
            return pos[v];
        }
        //获取堆数组位置为i的元素的权值，也就是与起点的距离
        double getWeight(int i){
            return h[i].weight();
        }
        //更新堆的函数，设置新的权值
        void setWeight(int i,double val){
            h[i].setWeight(val);
            //要调整堆的结构
            siftup(i);
            if(n!=0)siftdown(i);
        }
        //调试用，输出最后的结果
        void show(){
            for (int i = 0; i < maxsize; i++) {
                System.out.print(h[i].vertex());
                System.out.print(",");
                System.out.println(h[i].weight());
            }
        }
    }
    void dijkstra(graph g){
        //创建用于堆的数组
        edge[]e=new edge[g.n()];
        //初始化这个数组，由于是对象数组所以要new一遍
        for (int i = 0; i < e.length; i++) {
            e[i]=new edge(i,Double.POSITIVE_INFINITY);
        }
        //把起点的内容添加进堆数组
        e[0].setWeight(0);
        heap p=new heap(e,e.length,e.length);
        //把邻接于起点的点加进堆中并更新与起点的距离（因为初始化都为无穷)
        for(int x=g.first(0);x<g.n();x=g.next(0,x))p.setWeight(p.getPos(x),g.weight(0,x));
        for (int i = 0; i < g.n()-1; i++) {
            //从堆顶取出距原点最近的点
            int y=p.remove();
            //访问它的相邻节点，若它到原点的距离+它到相邻节点的距离<它的相邻节点到原点的距离，更新它的
            //相邻节点到原点的距离
            for(int x=g.first(y);x<g.n();x=g.next(y,x)){
                if(p.getWeight(p.getPos(y))+g.weight(y,x)<p.getWeight(p.getPos(x))){
                    p.setWeight(p.getPos(x),p.getWeight(p.getPos(y))+g.weight(y,x));
                }
            }
        }
        p.show();
    }
    public void test(){
        graph t=new graph(6);
        t.setEdge(0,1,1);
        t.setEdge(0,2,12);
        t.setEdge(1,2,9);
        t.setEdge(1,3,3);
        t.setEdge(2,4,5);
        t.setEdge(3,2,4);
        t.setEdge(3,5,15);
        t.setEdge(3,4,13);
        t.setEdge(4,5,4);
        dijkstra(t);
    }
}
```
