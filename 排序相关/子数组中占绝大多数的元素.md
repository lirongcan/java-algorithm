## 实现一个 MajorityChecker 的类，它应该具有下述几个 API：MajorityChecker(int[] arr) 会用给定的数组 arr 来构造一个 MajorityChecker 的实例。
## int query(int left, int right, int threshold) 有这么几个参数：
## 0 <= left <= right < arr.length 表示数组 arr 的子数组的长度。
## 2 * threshold > right - left + 1，也就是说阈值 threshold 始终比子序列长度的一半还要大。
## 每次查询 query(...) 会返回在 arr[left], arr[left+1], ..., arr[right] 中至少出现阈值次数 threshold 的元素，如果不存在这样的元素，就返回 -1。
### 算法思想如下：
#### 1.如果子区间长度小于50，就使用暴力搜索法，也就是用一个map记录每个元素在子区间出现的次数，如果次数超过阈值就输出它
#### 2.如果区间长度大于等于50，首先看下构造函数对整个数据结构的初始化如下：
#### （1）用content记录输入的数组arr，这个主要是为暴力搜索法服务
#### （2）使用一个List数组也就是List[]nums来作为一个哈希表，它的索引对应的就是arr[i]的值，然后把arr[i]出现的位置全部记录下来，而且数组第一个元素为
####      负的arr[i]主要是为了后面输出众数方便，例如数组1,1,2,2,3,3，那么nums[2]={-2,2,3}，后面的2，3就是2在数组中出现的索引
#### （3）使用一个二维List来把(2)中得到的所有list记录下来，然后根据list的长度也就是list.size()排序，用一个一维数组temp记录下来排序后所有的list.size()，为后面与阈值相比较提供方便
#### 3.在query中，首先是之前提到的暴力解法，然后如果区间长度较长，进行如下操作：
#### （1）在temp数组中利用二分查找找出比阈值大的第一个元素，然后在通过temp中的索引去找到之前建立的二维list中对应的list，然后通过二分在这个list中找到第一个大于left的元素和最后一个小于right的元素然后通过他们去计算区间[left,right]中对应元素arr[i]的出现次数，再与阈值比较即可。

```
class MajorityChecker {
    private Stack[] nums=new Stack[20001];
    private int[]temp;
    private int[]content;
    private List<Stack<Integer>>p=new Stack<>();
    public MajorityChecker(int[]arr){
        content=arr;
        for (int i = 0; i < arr.length; i++) {
            if(nums[arr[i]]==null){
                nums[arr[i]]=new Stack();
                nums[arr[i]].add(-arr[i]);
                p.add(nums[arr[i]]);
            }
            nums[arr[i]].add(i);
        }
        p.sort(new Comparator<Stack<Integer>>() {
            @Override
            public int compare(Stack<Integer> integers, Stack<Integer> t1) {
                return integers.size()-t1.size();
            }
        });
        temp=new int[p.size()];
        for (int i = 0; i < p.size(); i++) {
            temp[i]=p.get(i).size();
        }
    }
    public int query(int left,int right,int threshold){
        if(right-left<=50){
            HashMap<Integer,Integer>map=new HashMap<>();
            for (int i = left; i <= right; i++) {
                map.put(content[i],map.getOrDefault(content[i],0)+1);
                if(map.get(content[i])>=threshold)return content[i];
            }
            return -1;
        }
        else{
            int pos=Arrays.binarySearch(temp,threshold);
            if(pos<0){
                pos=-pos-1;
            }
            for (int i = pos; i < temp.length; i++) {
                int l=Collections.binarySearch(p.get(i),left);
                if(l<0){
                    l=-l-1;
                }
                int r=Collections.binarySearch(p.get(i),right);
                if(r<0){
                    r=-r-2;
                }
                if(r-l+1>=threshold)return p.get(i).get(0)*-1;
            }
            return -1;
        }
    }
}
```
